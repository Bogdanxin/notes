# Sentinel 的底层实现

## Sentinel的线程隔离与Hystix的线程隔离有什么差别？

Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。
Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。



## Sentinel 的限流与Gatway 有什么差别？

限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的令牌桶算法。
而Sentinel内部却比较复杂：

* 默认限流模式是基于滑动时间窗口算法
* 排队等待的限流模式则基于漏桶算法
* 而热点参数限流则是基于令牌桶算法




限流：对应用服务器的请求做限制，避免因过多请求而导致服务器过载甚至宕机

限流算法常见的包括两种：

1. 计数器算法，又包括窗口计数器算法、滑动窗口计数器算法
2. 令牌桶算法（Token Bucket）
3. 漏桶算法(Leaky Bucket)

### 固定窗口

![image-20220303201323914](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220303201323914.png)

具体实现如图所示，但是固定窗口是有一个问题的，因为时间是无界的，设定 4000ms~6000ms 内，发送了 6 个请求，但是是在 4500ms~5500ms 之内，也算是1s 内，但是却又 6 个请求。

### 滑动窗口

![image-20220303202124787](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220303202124787.png)

实现比较复杂，并且也不能够完全保证每个区间内都是不超过阈值的，比如上面的 1250 ~ 2100 也不到 1s

### 令牌桶

![image-20220303202450263](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220303202450263.png)

每秒生成固定数量的令牌，如果生成的令牌没有被消费，就进行保存。这样有好处也有坏处。

1. 好处是，当流量不稳定时，突发访问大量流量，可以消费之前剩下的令牌，从而能接收更多的流量。
2. 坏处是，和上面一样，因为有剩余令牌，所以一瞬间能够接收比较多的流量，但是不代表服务就能够处理这么多的流量，容易使服务崩溃。



**令牌桶的设计参考**

对于令牌桶的令牌生成，我们可以设置一个定时器，定时增加阈值数量的值；对于请求的服务，我们可以记录请求的时间，一秒内的服务请求，就判断个数不许超过阈值，不是一秒内的，就根据时间间隔判断生成的令牌个数，再减少取相应的令牌数。

### 漏桶模式

![image-20220303203842650](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220303203842650.png)

漏桶模式是对令牌桶的修改，能够实现流量改造，使其流量曲线变得更加平滑。

sentinel 中的实现，除了使用漏桶，还有一个特性：超时，也就是多余请求如果等待超时，也不会漏出去，只会被移除。



**设计参考**

消息队列（阻塞队列）

### 比较

![image-20220303204448397](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220303204448397.png)

