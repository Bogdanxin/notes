# 复杂度计算

## 时间复杂度

## 

大 O 时间复杂度表示法并不代表真正的执行时间，而是代表『**代码执行时间随数据规模增长的变化趋势**』，也叫做『渐进时间复杂度』。



时间复杂度分析方法：

1. 只关注循环执行次数最多的代码

2. 加法原则：总复杂度等于量级最大的那段代码的复杂度

    需要强调的是，一段代码中，如果是常量级的循环，即使是 10000 次 for，也不能够看为复杂度为 n，因为 n 代表着无穷，是可以远大于 10000 的数量。

3. 乘法原则：嵌套代码的复杂程度等于嵌套代码复杂程度乘积。

列出常见的复杂度量级：

| 复杂度量级（从左往右复杂度增长） |                                                              |
| -------------------------------- | ------------------------------------------------------------ |
| 多项式量级                       | 常量阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n²)、立方阶 O(n³)... |
| 非多项式量级                     | 指数阶 O(2^n)、阶乘阶 O(n!)                                  |

* O(1): 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

* O(logn) 和 O(nlogn)

    ```java
    int i;
    while (i < n) {
        i = i * 2;
    }
    ```

    例如这段代码，需要列出计算公式：

    ![image-20211213223858983](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/img/202112132238017.png)

    即可算出 x=log2n 那么就可推算出这个代码的复杂度为 O(logn)，那么 O(nlogn) 就是时间复杂度为 O(logn) 的代码运行 n 次。
    
    O(nlogn) 的是经常见的复杂度，并归排序，快速排序都是 O(nlogn)
    
* O(m + n) 和 O(m * n)

    ```java
    
    int cal(int m, int n) {
      int sum_1 = 0;
      int i = 1;
      for (; i < m; ++i) {
        sum_1 = sum_1 + i;
      }
    
      int sum_2 = 0;
      int j = 1;
      for (; j < n; ++j) {
        sum_2 = sum_2 + j;
      }
    
      return sum_1 + sum_2;
    }
    ```
    
    m 和 n 是两个不同的数据规模，都是无法确定的，所以就没办法使用加法原则了，所以只能两个复杂度都使用 O(m + n)，但是 O(m * n) 还是适用的。

最后总计一个复杂度的图

![image-20211214150739703](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/img/202112141507767.png)



