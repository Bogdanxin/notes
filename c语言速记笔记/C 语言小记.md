# C 语言小记

## 函数声明和函数定义

**函数声明**

> 为编译器提供了有用的信息，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令，所以函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。

如果使用**函数声明**，不需要对函数顺序进行排序了（先声明后使用）。

但是由于兼容的问题，存在函数声明的参数列表和函数定义的参数列表不一致的情况

```c
#include <stdio.h>
void newline();

int main(void) {
	printf("%%\n");
  newline(1);
	return 1;
}

int newline(int t) {
		printf("test\n");
		return t;
}
```



**隐式声明：**

> 函数的隐式声明（Implicit Declaration），在`main`函数中调用`threeline`时并没有声明它，编译器认为此处隐式声明了`int threeline(void);`，隐式声明的函数返回值类型都是`int`，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是`void`，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到`threeline`函数的原型是`void threeline(void)`，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确。

```c
#include <stdio.h>
void newline();

int main(void) {
	printf("%%\n");
	newline(1);
	return 1;
}

int newline(int t) {
	printf("test\n");
	return t;
}
```

## 全局变量、局部变量

**全局变量**：

相当于编译时就确定了的，局部变量在运行时才会被调用，所以全局变量必须是由常量定义，局部变量可以定义为一个函数的返回值。

```c
#include <stdio.h>
double flag = 1.0;

double a() {
	return 1.0;
}

double t = a();
int main(void) {
	return 0;
}
error: initializer element is not a compile-time constant
```

**局部变量：**

> 局部变量的存储空间在每次函数调用时分配，在函数返回时释放

## 结构体

结构体标准定义为：

```c
struct complex_struct {
    double x;
    double y;
};
```

以后如果需要声明一个结构体变量，需要 ``struct complex_struct ``定义，如果在后面加几个标志符，就相当于是声明了这几个变量

```c
struct complex_struct {
    double x;
    double y;
} a, b; 
```

就相当于声明了 a、b 两个结构体变量。

> Initializer中的数据依次赋给结构体的各成员。如果Initializer中的数据比结构体的成员多，编译器会报错，但如果只是末尾多个逗号则不算错。如果Initializer中的数据比结构体的成员少，未指定的成员将用0来初始化，就像未初始化的全局变量一样



## 枚举

```c
enum type {TYPE1, TYPE2}; // 默认从 0 开始
enum type {TYPE1 = 1, TYPE2};
```

## 数组

数组之间不能互相赋值

```c
int a[3] = {1, 2, 3};
int b[3] = a; // 错误
```

> 对于数组类型有一条特殊规则：**数组类型做右值使用时，自动转换成指向数组首元素的指针**。

### 字符串

```c
#include <stdio.h>

int main(void) {
	char c = "Hello, world.\n"[0];
	char str[10] = "hello";
	char str1[10] = "hello, world\n";
	char str2[] = "hello, world\n";
	printf("%c\n", c);
    printf("%s\n", str);
    printf("%s\n", str1);
    printf("%s", str2);
	return 0;
}
// char str1[10] = "hello, world\n"; 超过
```

`char str1[10] = "hello, world\n"; `长度超过 10，编译过程中会报警。如果运行，会找到'\0'为止。所以超过了 10 会异常。

## 宏定义 

`#define` 不仅定义常量，也可以定义更复杂的语法结构。相比于枚举，define 在预处理阶段被处理，枚举在编译阶段被处理。也就是在 cpp(c proprecessor) 命令时候执行的。



## gdb

**gdb基本命令1**

| 命令                | 描述                                                   |
| ------------------- | ------------------------------------------------------ |
| backtrace（或bt）   | 查看各级函数调用及参数                                 |
| finish              | 连续运行到当前函数返回为止，然后停下来等待命令         |
| frame（或f） 帧编号 | 选择栈帧                                               |
| info（或i） locals  | 查看当前栈帧局部变量的值                               |
| list（或l）         | 列出源代码，接着上次的位置往下列，每次列10行           |
| list 行号           | 列出从第几行开始的源代码                               |
| list 函数名         | 列出某个函数的源代码                                   |
| next（或n）         | 执行下一行语句                                         |
| print（或p）        | 打印表达式的值，通过表达式可以修改变量的值或者调用函数 |
| quit（或q）         | 退出`gdb`调试环境                                      |
| set var             | 修改变量的值                                           |
| start               | 开始执行程序，停在`main`函数第一行语句前面等待命令     |
| step（或s）         | 执行下一行语句，如果有函数调用则进入到函数中           |



## 计算机体系结构

### 设备

[设备](https://docs.huihoo.com/c/linux-c-programming/ch17s03.html)

> 操作系统（Operating System）本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的启动代码（称为Bootloader）首先把操作系统从磁盘加载到内存，然后执行操作系统中的代码把用户需要的其它程序加载到内存。操作系统和其它用户程序的不同之处在于：操作系统是常驻内存的，而其它用户程序则不一定，用户需要运行哪个程序，操作系统就把它加载到内存，用户不需要哪个程序，操作系统就把它终止掉，释放它所占的内存。操作系统最核心的功能是管理进程调度、管理内存的分配使用和管理各种设备，做这些工作的程序称为内核（Kernel），它在计算机启动时加载到内存并常驻内存。广义上操作系统的概念还包括一些必不可少的用户程序，比如Shell是每个Linux系统必不可少的，而Office办公套件则是可有可无的，所以前者也属于广义上操作系统的范畴，而后者属于应用软件。

中断：

我们在使用设备时，需要主动向 cpu 提供数据，或者索取数据。比如键盘输入，或者显示器输出。这时，需要设备通知 cpu，让其主动接收或发送数据。这里的『通知』就是**中断机制**实现的。如果设备需要 cpu 参与，就向 cpu 发送中断请求，然后：

> CPU正在执行的指令将被打断，程序计数器会指向某个固定的地址（这个地址由体系结构定义），于是CPU从这个地址开始取指令（或者说跳转到这个地址），执行中断服务程序（ISR，Interrupt Service Routine），完成中断处理之后再返回先前被打断的地方执行后续指令。比如某种体系结构规定发生中断时跳转到地址0x00000010执行，那么就要事先把一段ISR程序加载到这个地址，ISR程序是内核代码的一部分，在这段代码中首先判断是哪个设备引发了中断，然后调用该设备的中断处理函数做进一步处理

### MMU

首先引入两个概念：物理地址和虚拟地址。如果 MMU 没有启用，CPU 发送的内存地址将会直接通过芯片引脚传递到内存芯片（也可以称为**物理内存**）对应的地址上，这个地址就称为**物理地址**；相反，如果启用了 MMU，CPU 发送的内存地址会被 MMU 拦截，MMU 会将拦截的地址信息转换为实际的内存芯片中的地址。被拦截的地址就是**虚拟地址**，转换完成的就是**物理地址**。

> 操作系统和MMU是这样配合的：
>
> 1. 操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。
> 2. 设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。
>
> 我们在程序中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址，指令中的地址被CPU解释执行，就成了CPU执行单元发出的内存地址，所以在启用MMU的情况下，程序中使用的地址都是虚拟地址，都会引发MMU做查表和地址转换操作。

MMU 也可以提供内存保护机制。操作系统中分为两种模式：用户模式和特权模式，所以内存中也有对应的区域禁止用户访问，通过 MMU 就可以将拦截的地址进行判断，从而决定是否满足权限。

> MMU除了做地址转换之外，还提供内存保护机制。各种体系结构都有用户模式（User Mode）和特权模式（Privileged Mode）之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在CPU处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，访问权限又分为可读、可写和可执行三种。这样设定好之后，当CPU要访问一个VA时，MMU会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成PA，否则不允许访问，产生一个异常（Exception）。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由CPU内部产生，中断产生的原因和CPU当前执行的指令无关，而异常的产生就是由于CPU当前执行的指令出了问题，例如访问内存的指令被MMU检查出权限错误，除法指令的除数为0等都会产生异常。



## main函数启动和结束

### 启动

![asmc.link](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/asmc.link.png)

c 语言的『入口』是 main 函数，但是在汇编程序中，入口是`_start`。事实上，main 函数是被`_start`调用的。在链接过程，生成可执行文件，需要和其他目标文件一起链接，其中某个文件其实就是`_start`入口，通过入口调用 mian 函数，但是这个`_start`目标文件并没有自己定义 mian 函数，所以并不知道 main 函数的地址，只有通过链接才能够定位到。

同时我们可以发现还有一些`_libc_start_main`的其他目标文件，这些文件也没有定义，并且在可执行文件中也没有找到，这些文件就是『动态链接』。在执行过程中，操作系统会对这些**动态链接**进行查找，然后进行加载。

### main 结束

main 函数一般会有返回值，这个返回值就是在`_start`入口之后被接受的，接收到返回值后，会调用 exit的系统调用，从而终止该进程。



> 小结：c 语言中的 main 函数只是『名义上』的入口，其实要真正执行到 main 函数，需要其他函数的引导，也就是 _start 入口，并提供一个接口进入到 mian 函数。但是操作系统不能将这个任务交给程序员，所以自己提供一个目标文件，用来引导 main 函数。其实和 java 中的设计类似，将真正引导交给 jvm，程序员只关心自己需要的代码编写。
