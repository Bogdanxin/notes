# 汇编程序

> 汇编程序中以`.`开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个“伪”字。`.section`指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。`.data`段保存程序的数据，是可读可写的，相当于C程序的全局变量。
>
> `.text`段保存代码，是只读和可执行的，后面那些指令都属于`.text`段。
>
> `_start`是一个符号（Symbol），符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。
>
> `.globl`指示告诉汇编器，`_start`这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号。`_start`就像C程序的`main`函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的`_start`符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个`_start`符号并且用`.globl`声明。如果一个符号没有用`.globl`声明，就表示这个符号不会被链接器用到。

```asm
 .section .text
 .globl _start
_start:
 movl $1, %eax	# this is the linux kernel command
		# number (system call) for exiting
		# a program

 movl $4, %ebx	# this is the status number we will
		# return to the operating system.
		# Change this around and it will
		# return different things to
		# echo $?

 int $0x80	# this wakes up the kernel to run
		# the exit command
```

指令前面的代码就不用多说了，重点说一下 `int $0x80` 指令：

1. int 指令是 cpu 的软中断指令。通过生成一个异常，通知 cpu 处理，由用户模式转换到特权模式，然后cpu执行对应的内核代码，处理异常。
2. 这里的 $0x80 是`int`指令的参数，int 指令的参数会告知 cpu 该执行哪种内核代码。这里的 $0x80 是让 cpu 执行内核调用，也就是内核中的重要函数。cpu 会由正在执行的代码状态转换到系统调用的状态。
3. 系统调用函数也需要对应的参数，用于<font color=red>确定执行哪种系统调用以及这个调用对应的参数</font>，这里的参数就是上面两个 mov 指令。eax保存的是系统调用类型，eax 保存的是 1，对应的系统调用时`_exit`指令，表示退出状态。ebx 保存的是`_exit`指令的参数，也就是程序的返回值，这样 ebx 保存的是 4，等价于`return 4;`作用， 由此可知`_exit`指令作用就是终止当前的进程。

> 值得注意的是：
>
> 我们先通过 int 指令和对应参数确定相关的 cpu 软中断类型，跳转到cpu对应的中断处理机制中，如果是系统调用的话，再从相关的寄存器中获取参数，执行对应类型的系统调用



## 汇编程序的函数调用

[从汇编角度看待函数调用 ](https://segmentfault.com/a/1190000016661251)

[函数调用 ](https://docs.huihoo.com/c/linux-c-programming/ch19s01.html)

总结一下，汇编程序的函数调用其实是 c 语言的函数调用的细化。具体步骤主要两步：

1. 保存现场和传递参数
2. 跳转到目标地址

保存现场和传递参数是重点：当我们在进行函数调用前，首先将调用函数所需要的参数进行传递，这里就有两种情况，x86 系统和 x86_64系统。前者传递参数使用的压栈的方式，被调用函数取值会通过栈底指针 `$esp` 减内存地址的方式获取：`mov %edi,-0x4(%esp)`；后者使用寄存器传递参数，但是如果参数过多，寄存器不够用，就会继续使用压栈的方式，具体和之前类似。然后是保存现场，这个操作一般在 `call`指令中被执行，会将调用函数 `call` 指令下一条指令的地址保存在栈顶，这样被调用函数执行完毕后，恢复调用函数的栈帧，栈顶就是下一条指令地址，这样就可以直接跳转到那条指令，然后继续执行。

![image-20220605165743050](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/image-20220605165743050.png)

